# Type system

## Built-in

- Strings: &str, String, char (U00000...U1FFFF)
- Integral: i8, i16, i32, i64, i128, u8, u16, u32, u64, u128, usize, isize
For ints 2-s complement
0 literal for any
`_` can be inserted
*indexes always usize*
- Floating: f32, f64, f128 (unstable)
0.0 literal for any
- Logic: bool

## Operations

### Type conversion

Construction `as`

`Box<dyn std::error::Error>` <- unknown type

### Arithmetic

Both not and bitwise not: `!`
!Addition for ints: Wrapping semantic
!wrapping_add
!saturating_add <~ like clamp

## Tuple

Struct with unnamed fields (.0, .1, ...)

## Vec

`Vec<T>` <~ `std::vector<T>`

`let nums = vec![1, 2, 3];`

## Examples

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    Ok(())
}
```

```rust
let mut buf = String::new();
_ = std::io::stdin().read_line(&mut buf);
let mut iter = buf.split_ascii_whitespace();
let v1 = iter.next().ok_or("").parse::<i64>()?;
let v2 = v1 as i32;
println!("{}", v2);

// let v3 = i32::from(v1);
let v3 = i32::try_from(v1)?;
println!("{:?}", v3);
```

```rust
usize::MAX
usize::MIN
usize::BITS
10_u32.count_ones()

let v1, v2, v3, v4: i32
v1 + v2
v1.wrapping_add(v2)
v1.saturating_add(v2)
v1.overflow_add(v2)
v1.checked_add(v2)

```

```rust
let left, right: i32
for num in left..=right {

}
for num in (left..=right).rev() { // Reversed

}
```

```rust
let x: (i32, i64, bool, f64)
let y: (i32, i64, bool, f64)
y = x; // Copy

let (_, _, v, _) = x; // x: bool

```

```rust
fn solve(p: Vec<(i32, i32)>) -> i32 {

}
```

```rust
std::cmp::max();
```

```rust
use std::cmp::max;
max();
```

```rust
p: Vec<(i32, i32)>
let mut mv = i32::MIN;
p.iter().for_each(|&(v1, v2)| {
    mv = max(max(mv, v1), v2)
})
```

```rust
p.iter().fold(i32::MIN,|cur, &(v1, v2)| {
    max(max(cur, v1), v2)
})
```
